## Process this file with make_am to produce Makefile.am
SUBDIRS: include
CVS_HEADERS: cvs_headers
BODY:

AUTOMAKE_OPTIONS = foreign

noinst_LIBRARIES = libsymmetric.a
noinst_PROGRAMS = desTest desdata bf_test

# FIXME: Use the BASH variable to execute the script. The problem is
# that the script attempts to start itselt with "$0 args".

Makefile.am: Makefile.am.in
	(cd $(top_srcdir); ./make_am)

# When compiling with lsh, this is set to to -DLSH -I/path/to/lsh/include
# INCLUDES = @crypto_cpp_flags@

LDADD = libsymmetric.a
desdata_LDADD =

des_headers = parity.h rotors.h keymap.h 
BUILT_SOURCES =	desSmallFips.c desSmallCore.c desQuickFips.c desQuickCore.c \
	$(des_headers)

libsymmetric_a_SOURCES = desCode.h desKerb.c desUtil.c desQuick.c \
      $(BUILT_SOURCES) \
      sha.c md5.c idea.c arcfour.c cast.c blowfish.c

# Generate DES headers.
$(des_headers): desdata
	./desdata $@ > $@

desUtil.o: desUtil.c $(des_headers)

# Generate DES sources. Slowest to quickest.
desSmallFips.c:
		@echo > $@ '#include "desCode.h"' 
		@echo >> $@ 'ENCRYPT(DesSmallFipsEncrypt,TEMPSMALL,\
			     LOADFIPS,KEYMAPSMALL,SAVEFIPS)' 
		@echo >> $@ 'DECRYPT(DesSmallFipsDecrypt,TEMPSMALL,\
			     LOADFIPS,KEYMAPSMALL,SAVEFIPS)' 
desSmallCore.c:
		@echo > $@ '#include "desCode.h"' 
		@echo >> $@ 'ENCRYPT(DesSmallCoreEncrypt,TEMPSMALL,\
			     LOADCORE,KEYMAPSMALL,SAVECORE)' 
		@echo >> $@ 'DECRYPT(DesSmallCoreDecrypt,TEMPSMALL,\
			     LOADCORE,KEYMAPSMALL,SAVECORE)' 
desQuickFips.c:
		@echo > $@ '#include "desCode.h"' 
		@echo >> $@ 'ENCRYPT(DesQuickFipsEncrypt,TEMPQUICK,\
			     LOADFIPS,KEYMAPQUICK,SAVEFIPS)' 
		@echo >> $@ 'DECRYPT(DesQuickFipsDecrypt,TEMPQUICK,\
			     LOADFIPS,KEYMAPQUICK,SAVEFIPS)' 
desQuickCore.c:
		@echo > $@ '#include "desCode.h"' 
		@echo >> $@ 'ENCRYPT(DesQuickCoreEncrypt,TEMPQUICK,\
			     LOADCORE,KEYMAPQUICK,SAVECORE)' 
		@echo >> $@ 'DECRYPT(DesQuickCoreDecrypt,TEMPQUICK,\
			     LOADCORE,KEYMAPQUICK,SAVECORE)' 

EXTRA_DIST = $(cvs_headers) Makefile.am.in descore.README

.PHONY: depend
depend:
	rm -f $(DEP_FILES)
	make $(DEP_FILES)

# .deps/%.P : %.c
# 	$(CC) $(CPPFLAGS) $(DEFS) -M -MG $< > $@

MAINTAINERCLEANFILES += $(DEP_FILES)

.PHONY: ctags-recursive ctags

ctags-recursive:
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  (cd $$subdir && $(MAKE) ctags); \
	done

ctags: ctags-recursive $(HEADERS) $(SOURCES) $(CONFIG_HEADER) $(TAGS_DEPENDENCIES) $(LISP)
	tags=; \
	here=`pwd`; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  test -f $$subdir/tags && tags="$$tags $$here/$$subdir/tags"; \
	done; \
	list='$(SOURCES) $(HEADERS)'; \
	unique=`for i in $$list; do echo $$i; done | \
	  awk '    { files[$$0] = 1; } \
	       END { for (i in files) print i; }'`; \
	test -z "$(CTAGS_ARGS)$(CONFIG_HEADER)$$unique$(LISP)$$tags" \
	  || (cd $(srcdir) && ctags --langmap=c:.c.x -o $$here/tags $(CTAGS_ARGS) $$tags $(CONFIG_HEADER) $$unique $(LISP))
# This treats .h.x files as C files rather than headers, but we can't
# distinguish them from .c.x files with ctags.

# Override the standard distclean-tags target, as this doesn't support `tags'
distclean-tags:
	-rm -f TAGS ID tags
